[ { "title": "Non-academic problem (Bridge Finding)", "url": "/posts/2024-08-10-non-academic-problem/", "categories": "codeforces, graph-theory", "tags": "codeforces, dfs, graph-theory, trees", "date": "2024-08-10 19:54:00 +0200", "snippet": "In CF 1986F: Non-academic problem we are given a simple undirected graph. The graph is connected, meaning that every vertex can be reached from every other vertex. Our task is to ruin this property...", "content": "In CF 1986F: Non-academic problem we are given a simple undirected graph. The graph is connected, meaning that every vertex can be reached from every other vertex. Our task is to ruin this property, as in “minimize the number of pairs $1 \\leq u \\lt v \\leq n$, between which there exists a path”. To do this, we are allowed to choose and remove a single edge.Understanding the ProblemBy removing an edge, the graph can be broken into two components. The number of connected pairs we would eliminate is the product of the number of vertices in the components. However, not all edges can split the graph in this way. An edge that connects two, otherwise disconnected subgraphs is called a bridge. Bridges in the graph below are marked in red.SolutionNotice that an edge is a bridge if and only if it does not belong to any cycle. If it is part of a cycle, then removing it does not break the graph because all paths that pass through the edge can be rerouted along the cycle. If it is not in any cycle, then there is no path that connects its two endpoints while avoiding the edge, and therefore removing it makes those two points disconnected.Cycles in a graph can be found via depth-first search. We can extend this algorithm to enumerate bridges. The DFS tree has the special property, that for every non-tree edge $(u, v)$ is a back edge, meaning that $v$ is an ancestor of $u$. Since every cycle contains at least one non-tree edge, if an edge $(u, v)$ is contained in a cycle, then by searching $v$’s subtree, a back edge that connects one of the descendants of $v$ to one of its ancestors can be found.We can keep count of such back edges, and when a vertex is finished, we can determine whether the edge between it and its parent is a bridge.Here, you can see a possible search tree starting from node $1$. The dashed lines mark back edges.To find possible solutions, we can run a second DFS to count the vertices in the subtree of each bridge. Let the number of vertices be $n$ in the whole graph, and $k$ in the current subtree. Then the graph has $\\binom{n}{2}$ paths in total, and we can break $k \\cdot (n - k)$ of those by removing the current edge.The complexity of this method is $O(n + m)$ since we only visit the vertices and edges once in each DFS.ImplementationThe below implementation involves a recursive version of DFS, extended to account for back edges. An edge is considered finished, if both of its endpoints are finished. We determine an edge $(u, v)$ to be a bridge, if and only if there are no unfinished back edges remaining in $v$’s subtree, after $v$ has been finished.In the second DFS, we count the vertices of the subtrees, and choose between the possible solutions at the bridges.#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;struct edge{ int t; // target node bool bridge;};struct node{ vector&lt;edge&gt; adj; bool vis; int bck; // helper variable for dfs_bridge};vector&lt;node&gt; g;int dfs_bridge(int p, int i){ node &amp;v = g[i]; if(v.vis) { ++v.bck; return 1; } // v.bck stores the number of back edges that end in v v.vis = true; int bck = 0; // count of the unfinished back edges in the subgraph for(edge &amp;e : v.adj) { if(e.t == p) continue; int r = dfs_bridge(i, e.t); bck += r; e.bridge = (r == 0); } // return the number of unfinished back edges return bck - v.bck * 2; // back edges that end in v were counted from both sides}int dfs_sol(int p, int i, ll &amp;best){ node &amp;v = g[i]; if(v.vis) { return 0; } v.vis = true; int count = 1; for(edge &amp;e : v.adj) { if(e.t == p) continue; int r = dfs_sol(i, e.t, best); if(e.bridge) // best stores the largest number of paths that can be broken best = max(best, ((ll)g.size() - r) * r); count += r; } // return the number of vertices in the subgraph return count;}int main(){ int t; cin &gt;&gt; t; while(t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; g = vector&lt;node&gt;(n); for(int i = 0; i &lt; m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; --u; --v; g[u].adj.push_back({ v, false }); g[v].adj.push_back({ u, false }); } // find bridges dfs_bridge(-1, 0); for(node &amp;v : g) v.vis = false; // find solutions ll best = 0; dfs_sol(-1, 0, best); cout &lt;&lt; (ll)n * (n - 1) / 2 - best &lt;&lt; endl; } return 0;}" }, { "title": "Competitive programming for pure mathematics", "url": "/posts/2024-04-03-pure-math/", "categories": "vprog, pure-math, projects", "tags": "vprog, pure-math, projects", "date": "2024-04-03 20:57:00 +0200", "snippet": "On April 10, we’ll host a special session by Dániel Varga (Rényi Institute of Mathematics, AI Lab),who works at the intersection of AI and pure mathematics. He will present numerous examples fromhi...", "content": "On April 10, we’ll host a special session by Dániel Varga (Rényi Institute of Mathematics, AI Lab),who works at the intersection of AI and pure mathematics. He will present numerous examples fromhis own work where a problem in pure mathematics (geometry, graph theory, algebra) can be advancedby translating it into an algorithm to find possible solutions to concrete cases. A competitive programmeris in a perfect position to execute such a translation, which is often just a few tens of lines of code,but running that code can provide important insights about the problem, or even solve it completely.The speaker will try to provide an opportunity for the most motivated members of the audience to getinvolved in such work. Although not the main focus of this session, the speaker will talk brieflyabout other research directions pursued at the Rényi AI Lab.Coordinates Time: 2024 April 10, Wednesday, 14:15 - 17:00 Place: BME Building I, Room IB134 (Inside the SZIT department on the 1st floor.)" }, { "title": "House Robbery (learning dynamic programming)", "url": "/posts/2024-03-08-house-robbery/", "categories": "leetcode, dynamic-programming", "tags": "leetcode, dp", "date": "2024-03-08 21:30:00 +0100", "snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent ho...", "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.Usually the first approach I see people come up with for this exercise goes something along the lines of: “let’s iterate the house arrayYou might try solving it with a heuristic, but there will be counterexamples to all of them. Heuristics are solutions where you always make a decision based on local information as you iterate your nums array.The problem is that when we make a decision whether to rob a house or not, it can never be undone later, if we find something better along the way. If we include a new house into the robbed ones, suddenly its neighbour cannot be included, so maybe the previous neighbour should be, and so on, the change might bubble up all the way to the beginning… how do we deal with these in an organized manner?Instead of sticking to a choice, check what happens in both cases! So for instance, we can either include the last house or not.If we include the n’th house, then obviously the n-1’th cannot be included… what we are left with is solving the same problem… for houses 1 .. n-2! And if we don’t include the n’th house … well then we must solve the problem for houses 1 .. n-1!So if we have a solver for between 1 .. n , maybe call it solve(n), this will be a recursive function, like so:nums = [0] + nums # Let's index houses from 1 to n, for better readability.def solver(i): # Solve or 1..i. # Base cases if i==0: # If we have no houses, we can rob 0 money. return 0 if i==1: # We can only rob the first house, so let's do it! return nums[1] return max(solver(i-2) + nums[i], solver(i-1))print(solve(n))But this is not too efficient. We call solver with n, then n-1 and n-2; the n-1 call will call for n-2 and n-3; the n-2 call will call for n-3 and n-4 … lots of redundancy there. If we know a solution to an n, we should just remember it.This is called memoization, the typo is intentional. Python can do it built-in, with the macro @cache, but let’s do it by hand now.nums = [0] + nums # Let's index houses from 1 to n, for better readability.dp = [-1]*len(nums)def solver(i): # Solve or 1..i. if dp[i] != -1: # If we already solved this case, return the solution. return dp[i] # Base cases if i==0: # If we have no houses, we can rob 0 money. dp[0] = 0 elif i==1: # We can only rob the first house, so let's do it! dp[1] = nums[1] # Generic case else: dp[i] = max(solver(i-2) + nums[i], solver(i-1)) return dp[i]print(solve(n))And at this point you can see that we’re using the recursion completely unnecessarily, we could just fill out that dp array from left to right :)nums = [0] + nums # Let's index houses from 1 to n, for better readability.dp = [-1]*len(nums)dp[0] = 0dp[1] = nums[1]for i in range(2,n+1): dp[i] = max(dp[i-2] + nums[i], dp[i-1])print(dp[n])And this is what we call dynamic programming!We relied on the principle of optimality, which means that an optimal solution to the problem for 1..n can be constructed from other optimal solutions to subproblems, 1..n-2 and 1..n-1 ! This is not true for all problems, consider finding a Hamiltonian path … you can’t just solve the problem for a subgraph, then try to build from there… maybe your edges have to be completely rearranged when a new vertex is added.This is such a powerful tool, because using the principle of optimality you can turn a naive 2^n solution (checking all subsets of houses and finding the maximum value that satisfies the constraint) into a linear one, since the value of the optimal subet from 1..n comes from the values of other optimal subsets from 1..n-1 and 1..n-2 .F.Y.I. Hamiltonian path can be solved with something called bitset dynamic programming, but that still has an exponential runtime and is a bit more trickier than this type of DP." }, { "title": "VProlog", "url": "/posts/2024-03-04-vprolog/", "categories": "vprog, vprolog", "tags": "vprog, vprolog", "date": "2024-03-04 20:00:00 +0100", "snippet": "This Wednesday on VProg Advanced, we’ll host a special session by Péter Szeredi, a prominent figure indeclarative programming and Prolog in Hungary, a professor from my department, BME VIK SZIT. Pr...", "content": "This Wednesday on VProg Advanced, we’ll host a special session by Péter Szeredi, a prominent figure indeclarative programming and Prolog in Hungary, a professor from my department, BME VIK SZIT. Prolog,short for “Programming in Logic,” emerged in the 1970s for tasks like natural language processing andautomated theorem proving. It remains a popular logic programming language even today.Prolog is an example of Good Old Fashioned AI (GOFAI), a symbolic and rule-based system. In contrast tocurrently popular approaches, such as machine learning and neural networks like ChatGPT, which strugglewith reasoning, Prolog excels at this task. Future AI technologies may combine these approaches into ahybrid system, called a “neuro-symbolic AI”, with Prolog’s reasoning power with ChatGPT’s naturallanguage capabilities.Links Slides and further materials: https://cs.bme.hu/~szeredi/vprogCoordinates Time: 2024 March 6, Wednesday, 14:15 - 17:00 Place: BME Building I, Room IB134 (Inside the SZIT department on the 1st floor.)UpdatesWe will have a total of 4 sessions! Session 1: 2024 March 6, Wednesday, 14:15 - 17:00 Session 2: 2024 March 13, Wednesday, 14:15 - 17:00 Session 3: 2024 March 20, Wednesday, 14:15 - 17:00 Session 4: 2024 March 27, Wednesday, 14:15 - 17:00" }, { "title": "VProg Student Club", "url": "/posts/2024-02-16-vprog-start/", "categories": "vprog, starting", "tags": "vprog, starting", "date": "2024-02-16 14:31:00 +0100", "snippet": "The VProg competitive programming study groups are continued this semester, organized by BME VIK SZIT!The study groups’ aim is to work together on improving our competitive programming skills and e...", "content": "The VProg competitive programming study groups are continued this semester, organized by BME VIK SZIT!The study groups’ aim is to work together on improving our competitive programming skills and expanding our knowledge on data structures and algorithms. We solve LeetCode-style exercises on platforms such as Codeforces, SPOJ, etc, in a ‘mob programming’ format, mostly using C++ and Python.We welcome anyone who is interested in competitive programming!We run two levels: VProg Introductory: Recommended for those, who have some basic knowledge in algorithms, such as sorting, binary search, graph travelsals, shortest path, etc and basic programming skills. VProg Advanced: Recommended for those, who have done competitive programming in the past (e.g. Nemes Tihamér, OKTV Programming, CEOI, IOI, Codeforces).Language is English by default, unless only Hungarians are present.Coordinates VProg Advanced: Mondays 12:15 - 15:00 and Wednesdays 14:15 - 17:00 Starting on 2024 February 19. Live @ BME, in room IB134. VProg Introductory: Fridays 16:00 - 18:00 Starting on 2024 February 23. Online, on Discord. Join us on Discord: https://vprog.hu/discordContact: Viktória Nemkin (nemkin@cs.bme.hu)" }, { "title": "VProg Student Club", "url": "/posts/2023-09-01-vprog-start/", "categories": "vprog, starting", "tags": "vprog, starting", "date": "2023-09-01 09:00:00 +0200", "snippet": "The VProg competitive programming study groups are continued this semester, organized by BME VIK SZIT!The study groups’ aim is to work together on improving our competitive programming skills and e...", "content": "The VProg competitive programming study groups are continued this semester, organized by BME VIK SZIT!The study groups’ aim is to work together on improving our competitive programming skills and expanding our knowledge on data structures and algorithms. We solve LeetCode-style exercises on platforms such as Codeforces, SPOJ, etc, in a ‘mob programming’ format, mostly using C++ and Python.We welcome anyone who is interested in competitive programming (however, some basic knowledge of algorithms, such as sorting, binary search, graph travelsals, shortest path, etc and basic programming skills are a must-have, to be able to keep up)!The sessions are held online, on Discord. We run both a Hungarian and an English session! :)Coordinates VProg-HU: Fridays, 16:00 - 18:00 Starting on 2023 September 15. Hungarian-speaking. VProg-EN: Mondays, 17:30 - 19:30 starting on 2023 September 11. English-speaking. Join us on Discord: https://vprog.hu/discordContact: Viktória Nemkin (nemkin@cs.bme.hu)" }, { "title": "VProg Student Club", "url": "/posts/2023-02-26-vprog-start/", "categories": "vprog, starting", "tags": "vprog, starting", "date": "2023-02-26 19:58:00 +0100", "snippet": "The VProg competitive programming study groups are continued this semester, organized by BME VIK SZIT!In the study groups we solve Codeforces and LeetCode-style exercises together, using C++ and P...", "content": "The VProg competitive programming study groups are continued this semester, organized by BME VIK SZIT!In the study groups we solve Codeforces and LeetCode-style exercises together, using C++ and Python, in a ‘mob programming’ format. Our goal is to prepare for the ACM ICPC competitions, held every year in the autumn semesters.We welcome anyone who is interested in algorithms! :)The sessions are online, on Discord.First session Time: 2023 March 10 (Friday) 15:00 - 17:00 Join: https://vprog.hu/discordContact Site: https://versenyprogramozas.hu/ E-mail: nemkin@cs.bme.hu" }, { "title": "VProg Student Club", "url": "/posts/2022-09-01-vprog-start/", "categories": "vprog, starting", "tags": "vprog, starting", "date": "2022-09-01 21:00:00 +0200", "snippet": "The competitive programming (ACM ICPC, Google Code Jam, Codeforces, etc) study groups are continued this semester, organized by BME VIK SZIT!Coordinates Time: Weekly on Friday, 15:00 - 16:30. Loc...", "content": "The competitive programming (ACM ICPC, Google Code Jam, Codeforces, etc) study groups are continued this semester, organized by BME VIK SZIT!Coordinates Time: Weekly on Friday, 15:00 - 16:30. Location: This semester is online, on Zoom.The study group is open to everyone: beginners and advanced students, students from other universities, and others outside of the university are also welcomed. :)Links (New!) Discord server: https://vprog.hu/discord Chat, organization, news, information. The Teams group is soon to be archived. :) Zoom meeting join: https://vprog.hu/zoom Join the online location. Codeforces group invite: https://vprog.hu/codeforces Submission of solutions, look at each other’s code. Miro board: https://vprog.hu/whiteboard Online whiteboard, that can be edited together. Viktória Nemkinnemkin@cs.bme.hu" }, { "title": "Wish I Knew How to Sort (an exercise in probability)", "url": "/posts/2022-04-12-wish-i-knew-how-to-sort/", "categories": "codeforces, probability-theory", "tags": "codeforces, probability-theory, expectation-value, markov-chain", "date": "2022-04-12 13:00:00 +0200", "snippet": "In this post I would like to talk about solving Codeforces 1753C: Wish I Knew How to Sort.In the exercise we receive a binary array $a$ with $n$ elements, which we want to sort. However, our algori...", "content": "In this post I would like to talk about solving Codeforces 1753C: Wish I Knew How to Sort.In the exercise we receive a binary array $a$ with $n$ elements, which we want to sort. However, our algorithms teacher forgot to teach us about sorting algorithms. :)For lack of a better idea, we choose a randomized method, in which a step looks like the following: We point to two positions in the array at random (with uniform distribution, independently of each other and of our previous steps). Let these be denoted by indices $i$ and $j$, where $i &lt; j$. If they are in the wrong order ($a_i &gt; a_j$), we swap them, otherwise we do nothing.This step is repeated until the array is sorted.Question: What is the expectation value of the steps taken?In the task, there is a technical detail that the solution must be written as an irreducible fraction (a fraction that can no longer be simplified), I will cover the method of doing this at the end.There are at least two very different solutions to the task, both of which are very useful to know for handling probabilistic exercises.ObservationThe first thing we can observe is that we know how many $0$s and $1$s are in the $a$ array, so we can already draw the borer between the $0$s and the $1$s in the resulting, sorted array.Then, based on the location of the randomly chosen pair $i &lt; j$, there are actually two different cases: $i$ is before the dividing line, $j$ is after it. Both are before or after the dividing line.In the first case, if there is a swap, we have done useful work, since we have increased the number of $0$s before the line and the number of $1$s after the line, bringing us closer to the desired state.In the second case, if there is a swap, we did not do useful work with it, since we only moved things within the border, we still have to move the same amount of $1$s from the left side of the border to the right side and replace them with $0$s.So it can be said that the exact location of the $0$s and $1$s is irrelevant, the only thing that matters is how many of them are on either side of the boundary line. A useful step occurs only when $i$ is before the boundary and $j$ is after the boundary, and $a_i = 1$ and $a_j = 0$. In all other cases, the step does not change the current state.First method: Geometric distribution and linearity of the expectation valueIf you know probability theory, you may recognize a notable distribution in the task: this is the geometric distribution. This appears when we “repeat something until something occurs”.A little detour: about the geometric distribution (for those who don’t know it yet)More precisely: We perform a series of random experiments. Among the possible outcomes of the experiments, we distinguish between “successful” and “failed” outcomes. We call a set of outcomes an event, so we have a “successful” and a “failed” event. The probability of the “successful” event is known, let’s denote it by $p$, the probability of the “failed” event is therefore $1-p$. The individual experiments are performed independently of each other (i.e. the probability of success is not affected by the results of the previous experiments). We stop when we get a successful result. We define a random variable that tells us how many steps we took before we stopped.For example, if the variable $X$ represents the number of steps, we can ask what the probability is that exactly $i$ steps were taken, i.e. $P(X=i) = ?$.This requires $i-1$ failed attempts and $1$ successful attempt, so\\(P(X=i) = (1-p)^{i-1}p\\).And the possible values of $i$ are any number of steps between $1$ and $\\infty$.The advantage of knowing notable distributions is, for example, that we know their expectation value. We denote this for the variable $X$ by $E(X)$. By definition, the expectation value is the sum of the possible values of a variable weighted by their probability, i.e\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i).\\](We can later talk about the fact that if we sample $X$ many times, i.e. carry out the series of random experiments and write down how many steps we took, then the average of the obtained step numbers will get closer and closer to this theoretical expectation value, but now we are in the territory of statistics. )The expectation value of the geometric distributionThe theoretical expectation value of the geometric distribution is $\\frac{1}{p}$, which can be easily calculated by substituting into the formula above:\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i) = \\sum\\limits_{i} i \\cdot{} (1-p)^{i-1}p = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1}\\]We have come across such infinite sums many times and they can be dealt with in many ways. Now we are mainly bothered by the $i$ multiplier, without which we would have a geometric series, so we should get rid of it.For example, we start from the original equality and see what it looks like if we start to expand it:\\[E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1} = p + 2p(1-p) + 3p(1-p)^2 + 4p(1-p)^3 + \\cdots{}\\]Multiply both sides by $(1-p)$:\\[(1-p) E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i} = p(1-p) + 2p(1-p)^2 + 3p(1-p)^3 + 4p(1-p)^4 + \\cdots{}\\]We notice that if we subtract the two from each other, we can get rid of the $i$ multipliers and get the sum of an infinite geometric series:\\[E(X) - (1-p) E(X) = p + p(1-p) + p(1-p)^2 + p(1-p)^3 + p(1-p)^4 + \\cdots{} = p \\sum\\limits_{i=0}^{\\infty} (1-p)^{i} = p \\cdot{} \\frac{1}{1-(1-p)} = 1\\]So\\[E(X) - E(X) + pE(X) = 1,\\]\\[pE(X) = 1,\\]\\[E(X) = \\frac{1}{p}.\\]It is worth remembering this result.Back to the taskThere is some kind of “do it until we succeed” feeling about the task, so we believe there is some geometric random variable in the background, the expectation value of which we now know. Let’s try to model the task in this way!It is quickly seen that a single variable is not enough to model the problem. Let’s think about it: then the stopping condition would be that the array has become sorted, for which a fixed probability $p$ would have to be determined, which should also be the same in each step, since the steps are independent. It won’t work that way. The steps are not independent this way.Instead, we can distribute the steps among several random variables: let the successful event be the one when our randomly chosen indices $i$ and $j$ fall on different sides of the boundary line and a swap is performed. There will be more than one of this event, which means we will need more than one random variables. However, fortunately, we can already tell from the initial array $a$ exactly how many variables are needed: as many successful events as are needed, i.e. how many $1$s are on the left side of the boundary: let’s denote this number with $k$ !Then the number of steps needed can be described as the sum of $k$ variables. Let $X_i$ be the variable that describes the number of steps needed to move from $i$ to $i-1$ number of $1$s on the left side (so that the last step was the only successful and useful swap in the sequence of steps needed).Then the number of steps can be described by the sum of the variables $X_k + X_{k-1} + \\cdots{} + X_1$, we need to calculate the expectation value of this sum, i.e. $E(X_k + X_{k-1} + \\cdots{} + X_1)$.Here we use a very important theorem, the linearity of expectation, i.e\\[E(X_k + X_{k-1} + \\cdots{} + X_1) = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1).\\]What is very surprising in this formula is that it is true even if the individual variables are not independent of each other and there are competitive programming tasks that strongly depend on this property. This is not the case now, here our variables will be independent, so this is perhaps less surprising, but for those of you, more interested in the topic, you can read about it here, for example: https://brilliant.org/wiki/linearity-of-expectation/.Then we only need to give a formula for $E(X_i)$. If there $i$ number of $1$s on the left side, then the probability of a successful swap, $p_i$ can be given with the formula favourable / total number of cases as follows: Since the array has $n$ elements, the total number of cases is how many ways I can choose an ordered pair of indices from the elements, this is $\\binom{n}{2}$. The number of favourable cases is how many ways I can choose a $1$ on the left side of the boundary and a $0$ on the right side. If there are $i$ pieces of $1$s on the left side, it means that there are the same number of $0$s on the right side, and we want to choose a pair of them, so $i\\cdot{}i = i^2$ is the number of favourable cases.So\\[p_i = \\frac{i^2}{\\binom{n}{2}}.\\]And it follows that the expectation value of a variable\\[E(X_i) = \\frac{1}{p_i} = \\frac{\\binom{n}{2}}{i^2}.\\]And the expectation value of the sum is\\[E = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1) = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2}.\\]At this point, we have solved the problem on a theoretical level, the only thing left to do is calculating this sum programatically.Before we do that, let’s first look at a completely different solution:Second method: Markov chain hitting times with dynamic programmingA little detour: about Markov chains (for those who don’t know it yet)In probability theory, Markov chains describe random processes that fulfill some kind of memorylessness criteria. Now I’m just going to talk about a special type of these, but for simplicity I’m just going to refer to them as Markov chains.For example, imagine a weather model that says: If the sun was shining yesterday, there is a $90\\%$ probability that the sun will also be shining today. If it rained yesterday, there is a $70\\%$ probability that it will also rain today.These statements can be illustrated with a diagram:This is an example of a very simple Markov chain. The chain has $2$ possible states, “sunny” and “rainy”. The random variable $X_i$ indicates the weather on day $i$. The above statements can be translated into the language of probability, with which we can specify the state transition probabilities of the chain: The probability that the weather is sunny on day $i$, provided that it was also sunny on the previous day, $i-1$: $P(X_i = sunny \\vert X_{i-1} = sunny) = 0.9$ The probability that the weather is rainy on day $i$, provided that it was sunny on the previous day, $i-1$: $P(X_i = rainy \\vert X_{i-1} = sunny) = 0.1$ The probability that the weather is sunny on day $i$, provided that it was rainy on the previous day, $i-1$: $P(X_i = sunny \\vert X_{i-1} = rainy) = 0.3$ The probability that the weather is rainy on day $i$, provided that it was also rainy on the previous day, $i-1$: $P(X_i = rainy \\vert X_{i-1} = rainy) = 0.7$This can be described in a concise way by the transition probability matrix (usually denoted by $\\Pi$):The matrix is stochastic, meaning that the sum of any column is $1$, since it is partition of the sample space: The events are pairwise disjoint, since according to our model there can only be one type of weather on a day. Their union is the entire sample space, since according to our model there is some kind of weather every day.The memorylessness condition (or the so-called Markov condition) here means that the weather of a given day depends only on the weather of the previous day, “not on the weather of any other past days”. This latter description worded mathematically correctly goes: if yesterday’s weather is known, today’s weather is independent of the weather of all other previous days.Back to the taskIn our exercise, we can recognize a similar Markov chain. The states of this should correspond to the number of $1$s on the left side of the boundary. We know that the possible values are $0, \\dots{}, k$, where $k$ is the value belonging to the starting array.We have previously specified the $p_i$ probabilities, which will be the transitional probabilities of this chain:Now the question is, what is the expectation number of steps until the chain reaches from state $k$ to state $0$?This is the so-called “hitting time” of the chain.It can be derived in general [1], as follows:[1]: https://mpaldridge.github.io/math2750/S08-hitting-times.htmlLet’s denote by $\\nu_{j\\leftarrow{}i} = \\nu_{j,i}$ that if the current state of the Markov chain is $i$, then what is the expectation value of the number of steps before it first reaches state $j$. If $i = j$, then $\\nu_{i,i} = 0$. In any other case, at least one step is required to reach state $j$. This one step will enter another state $s$, according to the probabilities written on the outgoing edges of state $i$. This other state $s$ also has some hitting time towards the target state. Due to the linearity of expectation, the following “self-referential formula” can be given: $S$ denotes the set of possible states. $p_{s,i}$ denotes value written in the transition probability matrix in row $s$ and column $i$, i.e. the probability of moving from state $i$ to state $s$. \\[\\nu_{j,i} = 1 + \\sum\\limits_{s\\in{}S} \\nu_{j,s}p_{s,i}\\]Here we used the Law of total expectation.This results in a very nice dynamic programming solution for our Markov chain. Since we want to reach state $0$, the only question is which state we came from, denote this with $k$. Let $dp[k]$ denote the hitting time from state $k$ to $0$. We know that in the case of $k\\neq{}0$, at least one step must be taken. This step can be unsuccessful (with probability $1-p_k$) or successful (with probability $p_k$). Substitute this into the general formula above:\\[dp[k] = 1 + (1-p_k) dp[k] + p_k dp[k-1]\\] And rearrange:\\[p_k \\cdot{} dp[k] = 1 + p_k \\cdot{} dp[k-1]\\]\\[dp[k] = \\frac{1}{p_k} + dp[k-1]\\] Furthermore:\\[dp[0] = 0\\]This clearly shows that\\[dp[k] = \\sum\\limits_{i=1}^{k} \\frac{1}{p_k}\\]Which is exactly the same formula that we derived from the geometric distribution solution! :)Printing the solution as an irreducible fractionIn the case of the first method, the following sum must be calculated:\\[E = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2} = \\frac{n(n-1)}{2}\\sum\\limits_{i=1}^{k}\\frac{1}{i^2}\\]Let’s bring the fractions in the sum to a common denominator!Let $D$ be the common denominator!\\[D = \\prod\\limits_{i=1}^{k}i^2\\]\\[E = \\frac{n(n-1)}{2} \\frac{\\sum\\limits_{i=1}^{k}\\frac{D}{i^2}}{D} = \\frac{P}{Q}\\]This is good for us, because the numerator and denominator of this fraction must be integer, so we can calculate them separately:\\[P = n(n-1) \\sum\\limits_{i=1}^{k}\\frac{D}{i^2}\\]\\[Q = 2D\\]And in Python, the third parameter of the pow function is the modulo, so the inverse of $Q$ with the modulo can be determined with it to calculate $\\frac{P}{Q}$.Source code:cases = int(input()) for _ in range(cases): n = int(input()) a = list(map(int, input().split())) border = 0 # Where is the border between the 0s and 1s of the final result. for i in range(n): if a[i] == 0: border += 1 k = 0 # The number of 1's before the border, that need to be swapped to the other side. for i in range(border): if a[i] == 1: k += 1 if k==0: print(0) continue D = 1 for i in range(1, k+1): D *= i*i S = 0 for i in range(1, k+1): S += D / (i * i) P = n*(n-1) * S Q = 2 * D mod = 998244353 QInv = pow(Q, -1, mod) print(int((P * QInv) % mod))And this results in a time limit exceeded at the moment. :) (TODO)" }, { "title": "Google Code Jam 2021 - Qualification Round", "url": "/posts/2021-04-16-google-code-jam-qualification-round/", "categories": "competitions", "tags": "google, codejam", "date": "2021-04-16 13:00:00 +0200", "snippet": "The 2021 Google Code Jam Qualification Round took place a few weeks ago. The duration of this round is 30 hours, so no matter which timezone you live in around the world, you have more than a whole...", "content": "The 2021 Google Code Jam Qualification Round took place a few weeks ago. The duration of this round is 30 hours, so no matter which timezone you live in around the world, you have more than a whole day to solve the tasks. To advance to the next round, you must have collected at least 30 points, and as usual, it wasn’t necessary to solve all the tasks to do so.The tasks this year were the following: Reversort (7 pont) Moons and Umbrellas (5, 11, 1 pont) Reversort Engineering (7, 11 pont) Median Sort (7, 11, 10 pont) Cheating Detection (11, 20 pont)Let’s look at how we could advance to the next round!1st Task: ReversortDescriptionReversort is an algorithm, that can sort a list of distinct integers in ascending order, using the “Reverse” operation.Each application of this operation reverses the order of some continuous part of the list.The pseudocode of the algorithm is the following:Reversort(L): for i := 1 to length(L) - 1 j := index of the minimum in L[i..] Reverse(L[i..j])The code above iterates over the array and in every step it swaps the number in the current position with the minimum number in the remaining array, such that the numbers between them will be put in reverse order, by reversing that continuous part of the array.We can see, that at the end of the loop, the numbers in the array will be sorted in ascending order.This algorithm is wasteful, the question is by how much. On the input, we receive an array of numbers in random order and we have to print the sum of the length of the subarrays reversed during the algorithm’s run.SolutionThere is only one test set. We can immediately see, that it is very small: $T=100$ cases, at most $N=100$ numbers in each. If we look at the algorithm above, it runs the loop $~N$ times, inside it finds the minimum in $~N$ steps and reverses in $~N$ steps also, which means that it requires around $2\\cdot{}N^2 = 2\\cdot{}10^4$ steps in total. It is important to know, that 1 second is around $10^7$ - $10^8$ instructions (a rough estimate for competitive programming), so we easily fit under 1 second. We have 10 seconds and 1 GB of memory in total for the tests, so we can easily fit into these limits if we just implement the pseudocode as is.It is a good idea to implement this task, because: It gives 7 points, which is a lot, compared to the 30 needed. We only have to translate the given pseudocode to a programming language, which is easy and fast. It has a Visible Verdict, so we can be sure we received those 7 points. The description of the task said, that there will be a similar task later, so we might kill two birds with one stone, if we deal with this task now.I choose Python, because it is compact and has a similar syntax to the pseudocode itself. I usually choose between C++ and Python during competitions, using C++ for more complex tasks, where I want to use the STL library and if the time limits are strict. In this case, Python is the better choice for me.I submitted the following code (without the comments):n = int(input()) # First line of the input: number of testcasesfor n_i in range(n): cost = 0 m = int(input()) # First line of the testcase: length of the array l = list(map(int, input().split(' '))) # Second line of the testcase: the array itself # Implementation of Reversort for i in range(m-1): j = l.index(min(l[i:m])) # Find the minimum element in the remainder of the array. cost += j-i+1 # Add the subarray's length to the total cost. l[i:j+1] = reversed(l[i:j+1]) # Reverse the subarray. print(f\"Case #{n_i+1}: {cost}\") # Print the solution in the correct format.We can see, that we barely had to change anything to implement Reversort in Python and we were done. I had some issues with indexing (lesson learned: all built-in functions in Python assume intervals are closed from the left and open from the right) and I didn’t know about list.index and the reversed functions, I had to look those up.We received 7 points so far, we need 23 more.2nd Task: Moons and UmbrellasDescriptionApart from the story, the task is the following: we receive a string, which contains the characters C, J and ?. We have to switch the ? characters to either C or J, such that in the resulting string, the weighted sum of the number of CJ and JC substrings is as small as possible. The number of CJs is weighted by X and the number of JCs by Y, these parameters are also given on the input.SolutionOf the three test sets, the first (for 5 points) is very small, the string can be of length 10 at most, so here we could try out all possible cases, which amount to at most $2^10$ possibilities. If we were in a situation that we have already solved a few of the other tasks and just these 5 points are missing from the 30, then it would be worth coding just this much and not dealing with the other test sets.The second test set (for 11 points) contains strings of length 1000 at most, which would be $2^1000$ possible solutions for each. Since $2^4 = 16 &gt; 10$, that is greater than $10^250$, which would be too much, even if we could calculate the weight in one step. This test set does not allow for a brute force solution, we have to do some thinking too, however for 11 points, it might be worth dealing with.However, the third test set (for 1 point) is very unsympathetic. It is only worth 1 point, but negative values can also appear among the weights, which must be handled in a completely opposite way (the number of substrings must be maximized instead of minimized), the length of the strings is also $1000$, so we cannot give a brute force algorithm and finally it is a Hidden Verdict, so we won’t even know immediately whether our submission was successful. This is the test case that is not worth dealing with, unless we think of something quick for this while solving the second test set, otherwise we would just be wasting our time.I submitted the following Python code for the first two test sets:n = int(input())for n_i in range(n): x, y, m = input().split() x = int(x) y = int(y) m = m.replace('?', '') xc = m.count('CJ') yc = m.count('JC') print(f\"Case #{n_i+1}: {x*xc + y*yc}\")If we want to just minimize the number of CJs and JCs, without caring about the weights first, then we could simply go through the string from left to right and replace every ? with the character to the left of it (which can no longer be ?, because we must have overwritten it in the previous step), or in the special case the string starts with ?’s, then replace them with the first non-? character, then we get such a minimized solution.We can observe, that no matter what we replace the ?’s with, there is no way to reduce CJ and JC counts, we could only add to it, since for example for every C?…?J, somewhere a CJ substring will occur. So this solution is the best for any non-negative X and Y weights.Finally, it’s much easier to just delete the ?’s, since the method above only “slides” the non-? characters next to each other, so it will not introduce a new alternation, it will only move the existing ones next to each other.For example for this input string:???JC??C??JCJIt will output this one:JJJJCCCCCCJCJWhich has the same number of CJ and JC substrings than the one which results from erasing the ?’s:JCCJCJAnd this can be done in one operation in Python (m.replace('?', '')).Python is a good choice here too, since it is concise and we have 10 seconds per test set, which is more than enough to run the code above.We received 16 more points, we need 7 more.3rd Task: Reversort EngineeringDescriptionThis is the task that starts the same way as Reversort, but now the roles are reversed: now on the input we get the length of the array and the cost and we have to output an array whose sorting will cost this much using Reversort (or write IMPOSSIBLE if this is not possible).SolutionFor the first test set, the length of the array can be at most 7. This is very convenient, because we can try the 7!=5040 possible permutations one by one, run the solution given in the first task on each of them and print a permutation for which the cost is correct. If there is none, then print IMPOSSIBLE. This test set is worth 7 points, which is exactly what we need, so with this solution we are actually done, we could end the competition here.The second test set is more difficult, the length of the array can be at most 100 and the brute force algorithm will run out of time on 100! cases. Since I’ve had a lot of time lest from the competition, I’ve decided to try to solve this test set too.The key to the solution is to think backwards: we start from the final result, the sorted list of length N, we iterate on it backwards and step by step we “reverse” subarrays of the length we choose, until we reach the starting, mixed up list. If we can choose the lengths of the subarrays in such a way that the total sum of their length is the required cost, then the resulting array is the solution. (And here, of course, we have to notice on the task is impossible.)The first observation is that we will use at least 1 cost in each step, since the task says that if the is the smallest element at the current position, we will still “flip” that one-element subarray. Since this will certainly arise as a cost at each position (n-1 times in total), it is worth deducting (accounting for) this at the beginning, so that during further calculations it will not happen that we have used up all the costs but have not yet reached the beginning of the array.The consequence of this is that the cost of reversing an array of length $k$ will be $k-1$ from now on, because $1$ has already been accounted for.And the next observation is that we can choose from the following costs in the given positions from back to front:(Here the array is indexed with 0…n-1, Reversort does not run on the last element of the array, so we start backwards at index $n-2$.) index n-2: 0 if the element on index n-2 is rotated in place, and 1 if indexes n-2 and n-1 are swapped. index n-3: 0,1,2, similarly. index n-4: 0,1,2,3, similarly.… index 0: 0,1,…,n-1.So the task is to assemble the required cost as an amount while we can choose 1 number in each step above. Since we can choose an arbitrarily small number in each step, it is a good strategy to choose the maximum possible in each iteration to reduce the remaining cost as much as possible, unless we exceed it. If the maximum value in the list of possible choices is already more than the remaining cost, then a value equal to the cost is available too and can be selected from the list, then we can choose 0 in the remaining iterations.I implemented this algorithm in Python:# First line of input: number of test cases.z = int(input())for z_i in range(z): # First line of test case: required array length, required cost value. n, c = map(int, input().split(' ')) # First, we quickly rule out impossible cases: # We know that the minimum possible cost is n-1, if the goal is # less than this, then it's impossible. if c &lt; n-1: print(f\"Case #{z_i+1}: IMPOSSIBLE\") continue # To get the maximum possible cost, we choose largest number in each step, # which is the sum of the numbers N,...,2 (there is no 1, because for the # last element Reversort is not run). if n*(n+1)/2-1 &lt; c: print(f\"Case #{z_i+1}: IMPOSSIBLE\") continue # The description of the test sets includes that 2&lt;n, this is unnecessary # here, I just didn't notice. if n == 1: print(f\"Case #{z_i+1}: 1\") continue # At this point a solution exists: # We account for the n-1 cost at the beginning: c -= (n-1) # Here I first calculate the costs in advance (this is not necessary, # it could also be done on the go): # In this array I will store for each starting index the end # of the subarray to be rotated. torev = list(range(n)) # Here I'm going forwards, it is only necessary in the next step to go # backwards. for i in range(n-1): # Here I calculate how much costs I can account for in this iteration # (or the length of the longest possible subarray, or if it is too long, # then I can take the entire remaining cost). j = min(n-1-i, c) # I store where the end of the rotated subarray is. Here I had to # think a bit about the indexes, if there is a +1/-1 somewhere, # but this one is the correct indexing. torev[i] = i + j # I remove from the total cost the value I accounted for in this iteration. c -= j # And here I play the previously stored rotations backwards and # generate the starting array: # We start from the ordered array of length n. l = list(range(1,n+1)) # i=n-2...0 for i in range(n-2,-1,-1): # End of the subarray to be rotated. j = torev[i] # Even more +1/-1 indexing questions. l[i:j+1] = reversed(l[i:j+1]) # Print the solution. st = \" \".join(map(str, l)) print(f\"Case #{z_i+1}: {st}\")There are many ways to calculate the solution here, it is probably not necessary to account for the $n-1$ cost in advance, we could notice on the go if we have run out of the allowed cost. This code could still be simplified by a lot. :)With this solution, we scored 18 more points, which is 41 points in total. Every test set we submitted had a Visible Verdict, so we can be sure that we’ve made it to the next round!" } ]
