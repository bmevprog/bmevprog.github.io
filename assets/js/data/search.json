[ { "title": "VProg önképzőkör 2023. ősz", "url": "/posts/2023-09-01-vprog-onkepzokor/", "categories": "onkepzokor", "tags": "onkepzokor", "date": "2023-09-01 12:00:00 +0200", "snippet": "Ebben a félévben is indul a BME VIK SZIT szervezésében a Versenyprogramozás önképzőkör!A körön algoritmuselméleti, elsősorban Codeforces, SPOJ és egyéb LeetCode jellegű feladatok közös megoldásával...", "content": "Ebben a félévben is indul a BME VIK SZIT szervezésében a Versenyprogramozás önképzőkör!A körön algoritmuselméleti, elsősorban Codeforces, SPOJ és egyéb LeetCode jellegű feladatok közös megoldásával foglalkozunk, főként C++ és Python nyelveken, “mob programming” formátumban.Célunk többek között az ICPC, a Sapientia ECN, a DEIK Regionális Programozó Csapatverseny és egyéb, online versenyekre történő felkészülés.Szeretettel várunk mindenkit, akit érdekel a versenyprogramozás! A hatékony részvételhez néhány alapvető algoritmuselméleti ismeret, mint például rendezések, bináris keresés, gráfbejárások, legrövidebb út keresése stb., valamint alapvető programozási ismeretek szükségesek.A foglalkozások az online térben, Discordon zajlanak. Magyar és angol nyelvű alkalmunk is van!Koordináták VProg-HU: péntekenként, 16:00 - 18:00 (budapesti idő) kezdés 2023. szept. 15. magyar nyelvű VProg-EN: hétfőnként, 17:30 - 19:30 (budapesti idő) kezdés 2023. szept. 11. angol nyelvű Discord: https://vprog.hu/discordKontakt: Viktória Nemkin (nemkin@cs.bme.hu)" }, { "title": "Wish I Knew How to Sort (an exercise in probability)", "url": "/posts/2022-04-12-wish-i-knew-how-to-sort/", "categories": "codeforces, probability-theory", "tags": "codeforces, probability-theory, expectation-value, markov-chain", "date": "2022-04-12 13:00:00 +0200", "snippet": "In this post I would like to talk about solving Codeforces 1753C: Wish I Knew How to Sort.In the exercise we receive a binary array $a$ with $n$ elements, which we want to sort. However, our algori...", "content": "In this post I would like to talk about solving Codeforces 1753C: Wish I Knew How to Sort.In the exercise we receive a binary array $a$ with $n$ elements, which we want to sort. However, our algorithms teacher forgot to teach us about sorting algorithms. :)For lack of a better idea, we choose a randomized method, in which a step looks like the following: We point to two positions in the array at random (with uniform distribution, independently of each other and of our previous steps). Let these be denoted by indices $i$ and $j$, where $i &lt; j$. If they are in the wrong order ($a_i &gt; a_j$), we swap them, otherwise we do nothing.This step is repeated until the array is sorted.Question: What is the expectation value of the steps taken?In the task, there is a technical detail that the solution must be written as an irreducible fraction (a fraction that can no longer be simplified), I will cover the method of doing this at the end.There are at least two very different solutions to the task, both of which are very useful to know for handling probabilistic exercises.ObservationThe first thing we can observe is that we know how many $0$s and $1$s are in the $a$ array, so we can already draw the borer between the $0$s and the $1$s in the resulting, sorted array.Then, based on the location of the randomly chosen pair $i &lt; j$, there are actually two different cases: $i$ is before the dividing line, $j$ is after it. Both are before or after the dividing line.In the first case, if there is a swap, we have done useful work, since we have increased the number of $0$s before the line and the number of $1$s after the line, bringing us closer to the desired state.In the second case, if there is a swap, we did not do useful work with it, since we only moved things within the border, we still have to move the same amount of $1$s from the left side of the border to the right side and replace them with $0$s.So it can be said that the exact location of the $0$s and $1$s is irrelevant, the only thing that matters is how many of them are on either side of the boundary line. A useful step occurs only when $i$ is before the boundary and $j$ is after the boundary, and $a_i = 1$ and $a_j = 0$. In all other cases, the step does not change the current state.First method: Geometric distribution and linearity of the expectation valueIf you know probability theory, you may recognize a notable distribution in the task: this is the geometric distribution. This appears when we “repeat something until something occurs”.A little detour: about the geometric distribution (for those who don’t know it yet)More precisely: We perform a series of random experiments. Among the possible outcomes of the experiments, we distinguish between “successful” and “failed” outcomes. We call a set of outcomes an event, so we have a “successful” and a “failed” event. The probability of the “successful” event is known, let’s denote it by $p$, the probability of the “failed” event is therefore $1-p$. The individual experiments are performed independently of each other (i.e. the probability of success is not affected by the results of the previous experiments). We stop when we get a successful result. We define a random variable that tells us how many steps we took before we stopped.For example, if the variable $X$ represents the number of steps, we can ask what the probability is that exactly $i$ steps were taken, i.e. $P(X=i) = ?$.This requires $i-1$ failed attempts and $1$ successful attempt, so\\(P(X=i) = (1-p)^{i-1}p\\).And the possible values of $i$ are any number of steps between $1$ and $\\infty$.The advantage of knowing notable distributions is, for example, that we know their expectation value. We denote this for the variable $X$ by $E(X)$. By definition, the expectation value is the sum of the possible values of a variable weighted by their probability, i.e\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i).\\](We can later talk about the fact that if we sample $X$ many times, i.e. carry out the series of random experiments and write down how many steps we took, then the average of the obtained step numbers will get closer and closer to this theoretical expectation value, but now we are in the territory of statistics. )The expectation value of the geometric distributionThe theoretical expectation value of the geometric distribution is $\\frac{1}{p}$, which can be easily calculated by substituting into the formula above:\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i) = \\sum\\limits_{i} i \\cdot{} (1-p)^{i-1}p = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1}\\]We have come across such infinite sums many times and they can be dealt with in many ways. Now we are mainly bothered by the $i$ multiplier, without which we would have a geometric series, so we should get rid of it.For example, we start from the original equality and see what it looks like if we start to expand it:\\[E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1} = p + 2p(1-p) + 3p(1-p)^2 + 4p(1-p)^3 + \\cdots{}\\]Multiply both sides by $(1-p)$:\\[(1-p) E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i} = p(1-p) + 2p(1-p)^2 + 3p(1-p)^3 + 4p(1-p)^4 + \\cdots{}\\]We notice that if we subtract the two from each other, we can get rid of the $i$ multipliers and get the sum of an infinite geometric series:\\[E(X) - (1-p) E(X) = p + p(1-p) + p(1-p)^2 + p(1-p)^3 + p(1-p)^4 + \\cdots{} = p \\sum\\limits_{i=0}^{\\infty} (1-p)^{i} = p \\cdot{} \\frac{1}{1-(1-p)} = 1\\]So\\[E(X) - E(X) + pE(X) = 1,\\]\\[pE(X) = 1,\\]\\[E(X) = \\frac{1}{p}.\\]It is worth remembering this result.Back to the taskThere is some kind of “do it until we succeed” feeling about the task, so we believe there is some geometric random variable in the background, the expectation value of which we now know. Let’s try to model the task in this way!It is quickly seen that a single variable is not enough to model the problem. Let’s think about it: then the stopping condition would be that the array has become sorted, for which a fixed probability $p$ would have to be determined, which should also be the same in each step, since the steps are independent. It won’t work that way. The steps are not independent this way.Instead, we can distribute the steps among several random variables: let the successful event be the one when our randomly chosen indices $i$ and $j$ fall on different sides of the boundary line and a swap is performed. There will be more than one of this event, which means we will need more than one random variables. However, fortunately, we can already tell from the initial array $a$ exactly how many variables are needed: as many successful events as are needed, i.e. how many $1$s are on the left side of the boundary: let’s denote this number with $k$ !Then the number of steps needed can be described as the sum of $k$ variables. Let $X_i$ be the variable that describes the number of steps needed to move from $i$ to $i-1$ number of $1$s on the left side (so that the last step was the only successful and useful swap in the sequence of steps needed).Then the number of steps can be described by the sum of the variables $X_k + X_{k-1} + \\cdots{} + X_1$, we need to calculate the expectation value of this sum, i.e. $E(X_k + X_{k-1} + \\cdots{} + X_1)$.Here we use a very important theorem, the linearity of expectation, i.e\\[E(X_k + X_{k-1} + \\cdots{} + X_1) = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1).\\]What is very surprising in this formula is that it is true even if the individual variables are not independent of each other and there are competitive programming tasks that strongly depend on this property. This is not the case now, here our variables will be independent, so this is perhaps less surprising, but for those of you, more interested in the topic, you can read about it here, for example: https://brilliant.org/wiki/linearity-of-expectation/.Then we only need to give a formula for $E(X_i)$. If there $i$ number of $1$s on the left side, then the probability of a successful swap, $p_i$ can be given with the formula favourable / total number of cases as follows: Since the array has $n$ elements, the total number of cases is how many ways I can choose an ordered pair of indices from the elements, this is $\\binom{n}{2}$. The number of favourable cases is how many ways I can choose a $1$ on the left side of the boundary and a $0$ on the right side. If there are $i$ pieces of $1$s on the left side, it means that there are the same number of $0$s on the right side, and we want to choose a pair of them, so $i\\cdot{}i = i^2$ is the number of favourable cases.So\\[p_i = \\frac{i^2}{\\binom{n}{2}}.\\]And it follows that the expectation value of a variable\\[E(X_i) = \\frac{1}{p_i} = \\frac{\\binom{n}{2}}{i^2}.\\]And the expectation value of the sum is\\[E = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1) = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2}.\\]At this point, we have solved the problem on a theoretical level, the only thing left to do is calculating this sum programatically.Before we do that, let’s first look at a completely different solution:Second method: Markov chain hitting times with dynamic programmingA little detour: about Markov chains (for those who don’t know it yet)In probability theory, Markov chains describe random processes that fulfill some kind of memorylessness criteria. Now I’m just going to talk about a special type of these, but for simplicity I’m just going to refer to them as Markov chains.For example, imagine a weather model that says: If the sun was shining yesterday, there is a $90\\%$ probability that the sun will also be shining today. If it rained yesterday, there is a $70\\%$ probability that it will also rain today.These statements can be illustrated with a diagram:This is an example of a very simple Markov chain. The chain has $2$ possible states, “sunny” and “rainy”. The random variable $X_i$ indicates the weather on day $i$. The above statements can be translated into the language of probability, with which we can specify the state transition probabilities of the chain: The probability that the weather is sunny on day $i$, provided that it was also sunny on the previous day, $i-1$: $P(X_i = sunny X_{i-1} = sunny) = 0.9$ The probability that the weather is rainy on day $i$, provided that it was sunny on the previous day, $i-1$: $P(X_i = rainy X_{i-1} = sunny) = 0.1$ The probability that the weather is sunny on day $i$, provided that it was rainy on the previous day, $i-1$: $P(X_i = sunny X_{i-1} = rainy) = 0.3$ The probability that the weather is rainy on day $i$, provided that it was also rainy on the previous day, $i-1$: $P(X_i = rainy X_{i-1} = rainy) = 0.7$ This can be described in a concise way by the transition probability matrix (usually denoted by $\\Pi$):The matrix is stochastic, meaning that the sum of any column is $1$, since it is partition of the sample space: The events are pairwise disjoint, since according to our model there can only be one type of weather on a day. Their union is the entire sample space, since according to our model there is some kind of weather every day.The memorylessness condition (or the so-called Markov condition) here means that the weather of a given day depends only on the weather of the previous day, “not on the weather of any other past days”. This latter description worded mathematically correctly goes: if yesterday’s weather is known, today’s weather is independent of the weather of all other previous days.Back to the taskIn our exercise, we can recognize a similar Markov chain. The states of this should correspond to the number of $1$s on the left side of the boundary. We know that the possible values are $0, \\dots{}, k$, where $k$ is the value belonging to the starting array.We have previously specified the $p_i$ probabilities, which will be the transitional probabilities of this chain:Now the question is, what is the expectation number of steps until the chain reaches from state $k$ to state $0$?This is the so-called “hitting time” of the chain.It can be derived in general [1], as follows:[1]: https://mpaldridge.github.io/math2750/S08-hitting-times.htmlLet’s denote by $\\nu_{j\\leftarrow{}i} = \\nu_{j,i}$ that if the current state of the Markov chain is $i$, then what is the expectation value of the number of steps before it first reaches state $j$. If $i = j$, then $\\nu_{i,i} = 0$. In any other case, at least one step is required to reach state $j$. This one step will enter another state $s$, according to the probabilities written on the outgoing edges of state $i$. This other state $s$ also has some hitting time towards the target state. Due to the linearity of expectation, the following “self-referential formula” can be given: $S$ denotes the set of possible states. $p_{s,i}$ denotes value written in the transition probability matrix in row $s$ and column $i$, i.e. the probability of moving from state $i$ to state $s$. \\[\\nu_{j,i} = 1 + \\sum\\limits_{s\\in{}S} \\nu_{j,s}p_{s,i}\\]Here we used the Law of total expectation.This results in a very nice dynamic programming solution for our Markov chain. Since we want to reach state $0$, the only question is which state we came from, denote this with $k$. Let $dp[k]$ denote the hitting time from state $k$ to $0$. We know that in the case of $k\\neq{}0$, at least one step must be taken. This step can be unsuccessful (with probability $1-p_k$) or successful (with probability $p_k$). Substitute this into the general formula above:\\[dp[k] = 1 + (1-p_k) dp[k] + p_k dp[k-1]\\] And rearrange:\\[p_k \\cdot{} dp[k] = 1 + p_k \\cdot{} dp[k-1]\\]\\[dp[k] = \\frac{1}{p_k} + dp[k-1]\\] Furthermore:\\[dp[0] = 0\\]This clearly shows that\\[dp[k] = \\sum\\limits_{i=1}^{k} \\frac{1}{p_k}\\]Which is exactly the same formula that we derived from the geometric distribution solution! :)Printing the solution as an irreducible fractionIn the case of the first method, the following sum must be calculated:\\[E = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2} = \\frac{n(n-1)}{2}\\sum\\limits_{i=1}^{k}\\frac{1}{i^2}\\]Let’s bring the fractions in the sum to a common denominator!Let $D$ be the common denominator!\\[D = \\prod\\limits_{i=1}^{k}i^2\\]\\[E = \\frac{n(n-1)}{2} \\frac{\\sum\\limits_{i=1}^{k}\\frac{D}{i^2}}{D} = \\frac{P}{Q}\\]This is good for us, because the numerator and denominator of this fraction must be integer, so we can calculate them separately:\\[P = n(n-1) \\sum\\limits_{i=1}^{k}\\frac{D}{i^2}\\]\\[Q = 2D\\]And in Python, the third parameter of the pow function is the modulo, so the inverse of $Q$ with the modulo can be determined with it to calculate $\\frac{P}{Q}$.Source code:cases = int(input()) for _ in range(cases): n = int(input()) a = list(map(int, input().split())) border = 0 # Where is the border between the 0s and 1s of the final result. for i in range(n): if a[i] == 0: border += 1 k = 0 # The number of 1's before the border, that need to be swapped to the other side. for i in range(border): if a[i] == 1: k += 1 if k==0: print(0) continue D = 1 for i in range(1, k+1): D *= i*i S = 0 for i in range(1, k+1): S += D / (i * i) P = n*(n-1) * S Q = 2 * D mod = 998244353 QInv = pow(Q, -1, mod) print(int((P * QInv) % mod))And this results in a time limit exceeded at the moment. :) (TODO)" }, { "title": "Google Code Jam 2021 - Qualification Round", "url": "/posts/2021-04-16-google-code-jam-qualification-round/", "categories": "competitions", "tags": "google, codejam", "date": "2021-04-16 13:00:00 +0200", "snippet": "The 2021 Google Code Jam Qualification Round took place a few weeks ago. The duration of this round is 30 hours, so no matter which timezone you live in around the world, you have more than a whole...", "content": "The 2021 Google Code Jam Qualification Round took place a few weeks ago. The duration of this round is 30 hours, so no matter which timezone you live in around the world, you have more than a whole day to solve the tasks. To advance to the next round, you must have collected at least 30 points, and as usual, it wasn’t necessary to solve all the tasks to do so.The tasks this year were the following: Reversort (7 pont) Moons and Umbrellas (5, 11, 1 pont) Reversort Engineering (7, 11 pont) Median Sort (7, 11, 10 pont) Cheating Detection (11, 20 pont)Let’s look at how we could advance to the next round!1st Task: ReversortDescriptionReversort is an algorithm, that can sort a list of distinct integers in ascending order, using the “Reverse” operation.Each application of this operation reverses the order of some continuous part of the list.The pseudocode of the algorithm is the following:Reversort(L): for i := 1 to length(L) - 1 j := index of the minimum in L[i..] Reverse(L[i..j])The code above iterates over the array and in every step it swaps the number in the current position with the minimum number in the remaining array, such that the numbers between them will be put in reverse order, by reversing that continuous part of the array.We can see, that at the end of the loop, the numbers in the array will be sorted in ascending order.This algorithm is wasteful, the question is by how much. On the input, we receive an array of numbers in random order and we have to print the sum of the length of the subarrays reversed during the algorithm’s run.SolutionThere is only one test set. We can immediately see, that it is very small: $T=100$ cases, at most $N=100$ numbers in each. If we look at the algorithm above, it runs the loop $~N$ times, inside it finds the minimum in $~N$ steps and reverses in $~N$ steps also, which means that it requires around $2\\cdot{}N^2 = 2\\cdot{}10^4$ steps in total. It is important to know, that 1 second is around $10^7$ - $10^8$ instructions (a rough estimate for competitive programming), so we easily fit under 1 second. We have 10 seconds and 1 GB of memory in total for the tests, so we can easily fit into these limits if we just implement the pseudocode as is.It is a good idea to implement this task, because: It gives 7 points, which is a lot, compared to the 30 needed. We only have to translate the given pseudocode to a programming language, which is easy and fast. It has a Visible Verdict, so we can be sure we received those 7 points. The description of the task said, that there will be a similar task later, so we might kill two birds with one stone, if we deal with this task now.I choose Python, because it is compact and has a similar syntax to the pseudocode itself. I usually choose between C++ and Python during competitions, using C++ for more complex tasks, where I want to use the STL library and if the time limits are strict. In this case, Python is the better choice for me.I submitted the following code (without the comments):n = int(input()) # First line of the input: number of testcasesfor n_i in range(n): cost = 0 m = int(input()) # First line of the testcase: length of the array l = list(map(int, input().split(' '))) # Second line of the testcase: the array itself # Implementation of Reversort for i in range(m-1): j = l.index(min(l[i:m])) # Find the minimum element in the remainder of the array. cost += j-i+1 # Add the subarray's length to the total cost. l[i:j+1] = reversed(l[i:j+1]) # Reverse the subarray. print(f\"Case #{n_i+1}: {cost}\") # Print the solution in the correct format.We can see, that we barely had to change anything to implement Reversort in Python and we were done. I had some issues with indexing (lesson learned: all built-in functions in Python assume intervals are closed from the left and open from the right) and I didn’t know about list.index and the reversed functions, I had to look those up.We received 7 points so far, we need 23 more.2nd Task: Moons and UmbrellasDescriptionApart from the story, the task is the following: we receive a string, which contains the characters C, J and ?. We have to switch the ? characters to either C or J, such that in the resulting string, the weighted sum of the number of CJ and JC substrings is as small as possible. The number of CJs is weighted by X and the number of JCs by Y, these parameters are also given on the input.SolutionOf the three test sets, the first (for 5 points) is very small, the string can be of length 10 at most, so here we could try out all possible cases, which amount to at most $2^10$ possibilities. If we were in a situation that we have already solved a few of the other tasks and just these 5 points are missing from the 30, then it would be worth coding just this much and not dealing with the other test sets.The second test set (for 11 points) contains strings of length 1000 at most, which would be $2^1000$ possible solutions for each. Since $2^4 = 16 &gt; 10$, that is greater than $10^250$, which would be too much, even if we could calculate the weight in one step. This test set does not allow for a brute force solution, we have to do some thinking too, however for 11 points, it might be worth dealing with.However, the third test set (for 1 point) is very unsympathetic. It is only worth 1 point, but negative values can also appear among the weights, which must be handled in a completely opposite way (the number of substrings must be maximized instead of minimized), the length of the strings is also $1000$, so we cannot give a brute force algorithm and finally it is a Hidden Verdict, so we won’t even know immediately whether our submission was successful. This is the test case that is not worth dealing with, unless we think of something quick for this while solving the second test set, otherwise we would just be wasting our time.I submitted the following Python code for the first two test sets:n = int(input())for n_i in range(n): x, y, m = input().split() x = int(x) y = int(y) m = m.replace('?', '') xc = m.count('CJ') yc = m.count('JC') print(f\"Case #{n_i+1}: {x*xc + y*yc}\")If we want to just minimize the number of CJs and JCs, without caring about the weights first, then we could simply go through the string from left to right and replace every ? with the character to the left of it (which can no longer be ?, because we must have overwritten it in the previous step), or in the special case the string starts with ?’s, then replace them with the first non-? character, then we get such a minimized solution.We can observe, that no matter what we replace the ?’s with, there is no way to reduce CJ and JC counts, we could only add to it, since for example for every C?…?J, somewhere a CJ substring will occur. So this solution is the best for any non-negative X and Y weights.Finally, it’s much easier to just delete the ?’s, since the method above only “slides” the non-? characters next to each other, so it will not introduce a new alternation, it will only move the existing ones next to each other.For example for this input string:???JC??C??JCJIt will output this one:JJJJCCCCCCJCJWhich has the same number of CJ and JC substrings than the one which results from erasing the ?’s:JCCJCJAnd this can be done in one operation in Python (m.replace('?', '')).Python is a good choice here too, since it is concise and we have 10 seconds per test set, which is more than enough to run the code above.We received 16 more points, we need 7 more.3rd Task: Reversort EngineeringDescriptionThis is the task that starts the same way as Reversort, but now the roles are reversed: now on the input we get the length of the array and the cost and we have to output an array whose sorting will cost this much using Reversort (or write IMPOSSIBLE if this is not possible).SolutionFor the first test set, the length of the array can be at most 7. This is very convenient, because we can try the 7!=5040 possible permutations one by one, run the solution given in the first task on each of them and print a permutation for which the cost is correct. If there is none, then print IMPOSSIBLE. This test set is worth 7 points, which is exactly what we need, so with this solution we are actually done, we could end the competition here.The second test set is more difficult, the length of the array can be at most 100 and the brute force algorithm will run out of time on 100! cases. Since I’ve had a lot of time lest from the competition, I’ve decided to try to solve this test set too.The key to the solution is to think backwards: we start from the final result, the sorted list of length N, we iterate on it backwards and step by step we “reverse” subarrays of the length we choose, until we reach the starting, mixed up list. If we can choose the lengths of the subarrays in such a way that the total sum of their length is the required cost, then the resulting array is the solution. (And here, of course, we have to notice on the task is impossible.)The first observation is that we will use at least 1 cost in each step, since the task says that if the is the smallest element at the current position, we will still “flip” that one-element subarray. Since this will certainly arise as a cost at each position (n-1 times in total), it is worth deducting (accounting for) this at the beginning, so that during further calculations it will not happen that we have used up all the costs but have not yet reached the beginning of the array.The consequence of this is that the cost of reversing an array of length $k$ will be $k-1$ from now on, because $1$ has already been accounted for.And the next observation is that we can choose from the following costs in the given positions from back to front:(Here the array is indexed with 0…n-1, Reversort does not run on the last element of the array, so we start backwards at index $n-2$.) index n-2: 0 if the element on index n-2 is rotated in place, and 1 if indexes n-2 and n-1 are swapped. index n-3: 0,1,2, similarly. index n-4: 0,1,2,3, similarly.… index 0: 0,1,…,n-1.So the task is to assemble the required cost as an amount while we can choose 1 number in each step above. Since we can choose an arbitrarily small number in each step, it is a good strategy to choose the maximum possible in each iteration to reduce the remaining cost as much as possible, unless we exceed it. If the maximum value in the list of possible choices is already more than the remaining cost, then a value equal to the cost is available too and can be selected from the list, then we can choose 0 in the remaining iterations.I implemented this algorithm in Python:# First line of input: number of test cases.z = int(input())for z_i in range(z): # First line of test case: required array length, required cost value. n, c = map(int, input().split(' ')) # First, we quickly rule out impossible cases: # We know that the minimum possible cost is n-1, if the goal is # less than this, then it's impossible. if c &lt; n-1: print(f\"Case #{z_i+1}: IMPOSSIBLE\") continue # To get the maximum possible cost, we choose largest number in each step, # which is the sum of the numbers N,...,2 (there is no 1, because for the # last element Reversort is not run). if n*(n+1)/2-1 &lt; c: print(f\"Case #{z_i+1}: IMPOSSIBLE\") continue # The description of the test sets includes that 2&lt;n, this is unnecessary # here, I just didn't notice. if n == 1: print(f\"Case #{z_i+1}: 1\") continue # At this point a solution exists: # We account for the n-1 cost at the beginning: c -= (n-1) # Here I first calculate the costs in advance (this is not necessary, # it could also be done on the go): # In this array I will store for each starting index the end # of the subarray to be rotated. torev = list(range(n)) # Here I'm going forwards, it is only necessary in the next step to go # backwards. for i in range(n-1): # Here I calculate how much costs I can account for in this iteration # (or the length of the longest possible subarray, or if it is too long, # then I can take the entire remaining cost). j = min(n-1-i, c) # I store where the end of the rotated subarray is. Here I had to # think a bit about the indexes, if there is a +1/-1 somewhere, # but this one is the correct indexing. torev[i] = i + j # I remove from the total cost the value I accounted for in this iteration. c -= j # And here I play the previously stored rotations backwards and # generate the starting array: # We start from the ordered array of length n. l = list(range(1,n+1)) # i=n-2...0 for i in range(n-2,-1,-1): # End of the subarray to be rotated. j = torev[i] # Even more +1/-1 indexing questions. l[i:j+1] = reversed(l[i:j+1]) # Print the solution. st = \" \".join(map(str, l)) print(f\"Case #{z_i+1}: {st}\")There are many ways to calculate the solution here, it is probably not necessary to account for the $n-1$ cost in advance, we could notice on the go if we have run out of the allowed cost. This code could still be simplified by a lot. :)With this solution, we scored 18 more points, which is 41 points in total. Every test set we submitted had a Visible Verdict, so we can be sure that we’ve made it to the next round!" } ]
