[ { "title": "VProg önképzőkör 2023. ősz", "url": "/posts/2023-09-01-vprog-onkepzokor/", "categories": "onkepzokor", "tags": "onkepzokor", "date": "2023-09-01 12:00:00 +0200", "snippet": "Ebben a félévben is indul a BME VIK SZIT szervezésében a Versenyprogramozás önképzőkör!A körön algoritmuselméleti, elsősorban Codeforces, SPOJ és egyéb LeetCode jellegű feladatok közös megoldásával...", "content": "Ebben a félévben is indul a BME VIK SZIT szervezésében a Versenyprogramozás önképzőkör!A körön algoritmuselméleti, elsősorban Codeforces, SPOJ és egyéb LeetCode jellegű feladatok közös megoldásával foglalkozunk, főként C++ és Python nyelveken, “mob programming” formátumban.Célunk többek között az ICPC, a Sapientia ECN, a DEIK Regionális Programozó Csapatverseny és egyéb, online versenyekre történő felkészülés.Szeretettel várunk mindenkit, akit érdekel a versenyprogramozás! A hatékony részvételhez néhány alapvető algoritmuselméleti ismeret, mint például rendezések, bináris keresés, gráfbejárások, legrövidebb út keresése stb., valamint alapvető programozási ismeretek szükségesek.A foglalkozások az online térben, Discordon zajlanak. Magyar és angol nyelvű alkalmunk is van!Koordináták VProg-HU: péntekenként, 16:00 - 18:00 (budapesti idő) kezdés 2023. szept. 15. magyar nyelvű VProg-EN: hétfőnként, 17:30 - 19:30 (budapesti idő) kezdés 2023. szept. 11. angol nyelvű Discord: https://vprog.hu/discordKontakt: Viktória Nemkin (nemkin@cs.bme.hu)" }, { "title": "Bárcsak tudnék rendezni (egy valszámos feladat)", "url": "/posts/2022-04-12-barcsak-tudnek-rendezni/", "categories": "codeforces, valszam", "tags": "codeforces, valszam, varhato-ertek, markov-lanc", "date": "2022-04-12 13:00:00 +0200", "snippet": "Ebben a cikkben szeretnék egy kicsit bővebben a Codeforces 1753C: Wish I Knew How to Sort feladat megoldásairól beszélni.A feladatban kapunk egy bináris, $n$ elemű $a$ tömböt, amit rendezni szeretn...", "content": "Ebben a cikkben szeretnék egy kicsit bővebben a Codeforces 1753C: Wish I Knew How to Sort feladat megoldásairól beszélni.A feladatban kapunk egy bináris, $n$ elemű $a$ tömböt, amit rendezni szeretnénk, de sajnos az algel tanárunk elfelejtette megtanítani nekünk a rendezési algoritmusokat. :) Jobb ötlet híján egy randomizált módszert választunk, melyben egy lépés a következőképpen néz ki: Véletlenszerűen (egyenletes eloszlással, egymástól és a korábbi lépéseinktől függetlenül) rámutatunk két pozícióra a tömbben. Legyenek ezek $i$ és $j$ indexszel jelölve, ahol $i &lt; j$. Ha rossz sorrendben vannak ($a_i &gt; a_j$), megcseréljük őket, egyébként nem csinálunk semmit.Ezt a lépést addig ismételjük, amíg a tömb rendezett nem lesz.Kérdés: Mi a várható értéke a végrehajtott lépéseknek?A feladatban technikai részlet, hogy a megoldást irreducibilis (tovább már nem egyszerűsíthető alakú) törtként kell kiírni, ennek a módszerére a végén térek ki.A feladatnak legalább kettő, egymástól nagyon különböző megoldása van, mindkettőt nagyon hasznos ismerni valszámos feladatok kezeléséhez.MegfigyelésAz első dolog, amit a feladat kapcsán észreveszünk, hogy tudjuk hány darab $0$-ás és $1$-es található az $a$ tömbben, ami alapján be tudunk húzni egy elválasztó vonalat, ami majd a végeredményben a $0$-ák és $1$-esek határa lesz.Ezután a véletlenül választott $i &lt; j$ pár elhelyezkedése szerint tulajdonképpen két különböző eset van: $i$ az elválasztó vonal előtt, $j$ utána van. Mindkettő az elválasztó vonal előtt / után van.Az 1. esetben ha történik csere azzal hasznos munkát végeztünk, hiszen növeltük a $0$-ák számát a vonal előtt és az $1$-esek számát a vonal után, ezzel közelebb kerültünk a célállapothoz.A 2. esetben ha történik csere azzal nem végeztünk hasznos munkát, hiszen pusztán határokon belül mozgattunk dolgokat, továbbra is ugyanannyi $1$-est kell még a határ bal oldaláról a jobb oldalára mozgatni, miközben a helyükre $0$-ákat hozunk.Tehát elmondható, hogy a feladat szempontjából lényegtelen a $0$-ák és $1$-esek pontos elhelyezkedése, csak az számít, hogy hány darab található belőlük a határvonal egy-egy oldalán. Hasznos lépés csak akkor történik, amikor az $i$ a határ előtt és a $j$ a határ után van, továbbá $a_i = 1$ és $a_j = 0$. Minden más esetben a lépés nem változtat az aktuális állapoton.Első megoldási módszer: Geometriai eloszlás és várható érték linearitásaAki tanult valószínűségszámítást, az ráismerhet a feladatban egy nevezetes eloszlásra: ez a geometriai eloszlás. Ez mindig akkor kerül elő, amikor “addig ismétlünk valamit, amíg nem sikerül”.Egy kis kitérő: a geometriai eloszlásról (annak, aki még nem ismeri)Pontosabban: Egy véletlen kísérletsorozatot hajtunk végre. A kísérleteknek lehetséges kimenetelei közül megkülönböztetünk “sikeres” és nem “sikeres” kimeneteleket. A kimenetelek halmazát szoktuk eseménynek hívni, tehát van egy “sikerült” és egy “nem sikerült” eseményünk. A “sikeres” esemény valószínűsége ismert, jelölje $p$, a “nem sikeres” esemény valószínűsége ekkor $1-p$. Az egyes kísérleteket egymástól függetlenül végezzük (azaz a sikeresség valószínűségét nem befolyásolják a korábbi kísérletek eredményei). Akkor állunk meg, amikor sikeres eredményt kapunk. Definiálunk egy (valószínűségi) változót, ami azt mondja meg, hogy hány lépést végeztünk.Például ha az $X$ változó jelöli a lépések számát, akkor feltehetjük azt a kérdést, hogy mennyi a valószínűsége annak, hogy pontosan $i$ darab lépést végeztünk, azaz $P(X=i) = ?$.Ehhez kellett $i-1$ darab sikertelen, majd $1$ darab sikeres kísérlet, tehát\\(P(X=i) = (1-p)^{i-1}p\\).$i$ lehetséges értékei pedig $1$ és $\\infty$ között bármilyen lépésszám.A nevezetes eloszlások ismeretének előnye például, hogy tanuljuk a várható értéküket. Ezt az $X$ változóhoz $E(X)$-el jelöljük az angol “expectation value” kifejezésből. Definíció szerint a várható értéke egy változónak a lehetséges értékeinek a valószínűségükkel súlyozott összege, azaz\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i).\\](Aztán lehet később arról beszélni, hogy ha mintavételezzük $X$-et sokszor, azaz végrehajtjuk a véletlen kísérletsorozatot és felírjuk hány lépést végeztünk, akkor a kapott lépésszámok átlaga egyre jobban megközelíti majd ezt az elméleti várható értéket, de ez már a statisztika világa.)A geometriai eloszlás várható értékeA geometriai eloszlás elméleti várható értéke például $\\frac{1}{p}$, ezt a fenti képletbe helyettesítéssel könnyen ki is számolhatjuk:\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i) = \\sum\\limits_{i} i \\cdot{} (1-p)^{i-1}p = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1}\\]Ilyen végtelen összegekkel már sokszor találkoztunk és sokféleképpen el lehet bánni velük. Most főleg az az $i$ szorzó zavar minket, anélkül mértani sor lenne, tehát ettől kellene megszabadulni.Például kiindulunk az eredeti egyenlőségből és nézzük meg hogy néz ez ki ha elkezdjük kifejteni:\\[E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1} = p + 2p(1-p) + 3p(1-p)^2 + 4p(1-p)^3 + \\cdots{}\\]Szorozzuk meg mindkét oldalt $(1-p)$-vel:\\[(1-p) E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i} = p(1-p) + 2p(1-p)^2 + 3p(1-p)^3 + 4p(1-p)^4 + \\cdots{}\\]Észrevehetjük, hogy ha kivonjuk egymásból a kettőt, akkor azzal pont az $i$-s szorzóktól szabadulunk meg és egy végtelen mértani sor összegét kapjuk:\\[E(X) - (1-p) E(X) = p + p(1-p) + p(1-p)^2 + p(1-p)^3 + p(1-p)^4 + \\cdots{} = p \\sum\\limits_{i=0}^{\\infty} (1-p)^{i} = p \\cdot{} \\frac{1}{1-(1-p)} = 1\\]Azaz\\[E(X) - E(X) + pE(X) = 1,\\]\\[pE(X) = 1,\\]\\[E(X) = \\frac{1}{p}.\\]Érdemes erre az eredményre emlékezni.Vissza a feladathozValamilyen “addig csináljuk amíg nem sikerül” érzésünk van a feladattal kapcsolatban, tehát valamilyen geometriai valószínűségi változó lesz a háttérben, aminek mostmár ismerjük a várható értékét. Próbáljuk meg valahogy így modellezni a feladatot!Hamar érezhető, hogy egyetlen változó kevés ahhoz, hogy modellezzük a problémát. Gondoljunk csak bele: ekkor a megállási feltétel az lenne, hogy “rendezetté vált” a tömb, ennek kellene egy fix $p$ valószínűséget meghatározni, ami minden lépésben ráadásul ugyanannyi kellene hogy legyen, hiszen a lépések függetlenek. Ez így nem fog működni.Helyette megtehetjük azt, hogy a lépéseket szétosztjuk több valószínűségi változó között: legyen a sikeres esemény inkább az, amikor a véletlenül választott $i$ és $j$ indexeink a határvonal két oldalára esnek és végrehajtódik egy csere. Ebből az eseményből több is lesz, vagyis több valószínűségi változóra lesz szükségünk. Azonban szerencsére már a kiindulási $a$ tömbből meg tudjuk mondani, hogy pontosan hány változóra van szükség: annyira, ahány sikeres eseményre szükség van, azaz ahány $1$-es van a határvonal bal oldalán: tegyük fel, hogy ez a szám $k$!Ekkor a szükséges lépések számát leírhatjuk $k$ darab változó összegeként. Legyen $X_i$ az a változó, ami azon lépések számát írja le, ami ahhoz kell, hogy a bal oldalon $i$ darab $1$-esből $i-1$ darab $1$-est csináljunk (tehát az utolsó lépés volt az egyetlen sikeres és hasznos csere a lépéssorozatban).Ekkor a lépések számát mostmár az $X_k + X_{k-1} + \\cdots{} + X_1$ változók összege fogja leírni, nekünk pedig ennek az összegnek a várható értékét, azaz $E(X_k + X_{k-1} + \\cdots{} + X_1)$-et kell megmondanunk.Itt van szükség arra a nagyon fontos valszám tételre, hogy a várható érték lineáris, azaz\\[E(X_k + X_{k-1} + \\cdots{} + X_1) = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1).\\]Ami nagyon meglepő ebben az összefüggésben az az, hogy ez még akkor is igaz, ha az egyes változók egymástól nem függetlenek és vannak is olyan vprog feladatok, ahol ezt a tulajdonságot nagyon erősen kihasználjuk. Ez most nem ilyen, itt a változóink függetlenek lesznek, ezért ez talán kevésbé meglepő, de akit érdekel a téma, például itt olvashat ezzel kapcsolatban: https://brilliant.org/wiki/linearity-of-expectation/. Lehet hozok majd erre építő feladatot is önképzőkörre. :)Ekkor már csak egy $E(X_i)$-t kell megmondanunk. Amennyiben $i$ darab $1$-es van a bal oldalon, akkor a $p_i$ sikeres csere valószínűséget felírhatjuk a kedvező / összes eset darabszám hányadossal a következőképpen: Mivel $n$ elemű a tömb, az összes eset az, hogy hányféleképpen tudok egy rendezett indexpárt kiválasztani az elemek közül, ez $\\binom{n}{2}$. A kedvező esetek száma az, hogy hányféleképpen tudok $1$-est választani a határvonal bal oldalán és $0$-ást a jobb oldalán. Amennyiben $i$ darab $1$-es van bal oldalt, tuti hogy ugyanennyi $0$-ás van jobb oldalt, ezekből akarunk egy párt választani, azaz $i\\cdot{}i = i^2$ a kedvező esetek száma.Tehát\\[p_i = \\frac{i^2}{\\binom{n}{2}}.\\]Ebből pedig következik, hogy a várható értéke egy változónak\\[E(X_i) = \\frac{1}{p_i} = \\frac{\\binom{n}{2}}{i^2}.\\]Az összeg várható értéke pedig\\[E = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1) = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2}.\\]Tulajdonképpen ezzel meg is oldottuk a feladatot elméleti szinten, ennek az összegnek a kiszámítását kell leprogramozni.Mielőtt ezt megtennénk, nézzünk meg először egy teljesen másik megoldást:Második megoldási módszer: Markov-lánc elérési idők dinamikus programozássalEgy kis kitérő: a Markov-láncokról (annak, aki még nem ismeri)A Markov-láncok valószínűségszámításban olyan véletlen folyamatokat írnak le, melyek teljesítenek valamilyen fajta memóriamentességi kritériumot. Most ezeknek egy speciális fajtájáról fogok csak beszélni, de az egyszerűség kedvéért csak Markov-láncként fogok hivatkozni rájuk.Képzeljünk el például egy olyan időjárási modellt, ami a következőket állítja: Ha tegnap sütött a nap, akkor ma $90\\%$ valószínűséggel szintén sütni fog a nap. Ha tegnap esett az eső, akkor ma $70\\%$ valószínűséggel szintén esni fog az eső.Ezeket az állításokat egy ábrán szemléltethetjük:Ez példa egy nagyon egyszerű Markoc-láncra. A láncnak $2$ lehetséges állapota van, “napos” és “esős”. Az $i.$ napon az $X_i$ valószínűségi változóval jelöljük, hogy milyen idő volt. A fenti állításainkat lefordíthatjuk a valószínűségszámítás nyelvére, mellyel a lánc állapotátmeneti valószínűségeit adhatjuk meg: Annak a valószínűsége, hogy az $i.$ napon napos az idő, feltéve hogy az előző, $i-1.$ napon is napos volt: $P(X_i = napos X_{i-1} = napos) = 0.9$ Annak a valószínűsége, hogy az $i.$ napon esős az idő, feltéve hogy az előző, $i-1.$ napon napos volt: $P(X_i = esős X_{i-1} = napos) = 0.1$ Annak a valószínűsége, hogy az $i.$ napon napos az idő, feltéve hogy az előző, $i-1.$ napon esős volt: $P(X_i = napos X_{i-1} = esős) = 0.3$ Annak a valószínűsége, hogy az $i.$ napon esős az idő, feltéve hogy az előző, $i-1.$ napon is esős volt: $P(X_i = esős X_{i-1} = esős) = 0.7$ Ehhez szokott tartozni egy állapotátmeneti (általában $\\Pi$-vel jelölt) mátrix:A mátrix oszlopai pedig $1$-re összegződnek, hiszen teljes eseményrendszerről van szó: Egymást páronként kizárják, hiszen a modellünk szerint egy napon csak egyféle időjárás lehet. Együtt kiadják a biztos eseményt, hiszen a modellünk szerint minden nap van valamilyen időjárás.A memóriamentességi feltétel (vagy ú.n. Markov-feltétel) itt azt jelenti, hogy az adott napi időjárás csak az azt megelőző nap időjárásától függ, “nem pedig az összes múltbéli nap időjárásától”. Ezt az utóbbi idézőjelbe tett szöveget valszámos nyelven úgy kell megfogalmazni, hogy amennyiben a tegnapi időjárás ismert, úgy a mai nap időjárása független minden korábbi nap időjárásától.Vissza a feladathozFeladatunkban felismerhetünk egy hasonló Markov-láncot. Ennek az állapotai legyenek azok, hogy az adott sorozatban éppen hány darab $1$-es szerepel a határvonal bal oldalán. Tudjuk, hogy ennek a lehetséges értékei $0, \\dots{}, k$, ahol $k$ a kiindulási tömbhöz tartozó érték.Korábban már megadtuk a $p_i$ valószínűségeket, melyek pont ennek a láncnak az átmeneti valószínűségei lesznek:A kérdés pedig most az, hogy mennyi a várható lépések száma, amíg a lánc a $k$ állapotból a $0$ állapotba ér?Ez az úgynevezett “hitting time”, vagy magyarul elérési idő.Általánosan levezethető [1], a következők szerint:[1]: https://mpaldridge.github.io/math2750/S08-hitting-times.htmlJelöljük $\\nu_{j\\leftarrow{}i} = \\nu_{j,i}$-vel azt, hogy ha a Markov-lánc aktuális állapota $i$, akkor várhatóan hány lépés után lesz a lánc állapota először $j$. Ha $i = j$, akkor $\\nu_{i,i} = 0$. Egyébként $\\nu_{j,i}$-re pedig kell legalább egy lépés. Ez az egy lépés az állapot kimenő éleire írt valószínűségekkel fog másik $s$ állapotba lépni. Ehhez a másik $s$ állapothoz szintén tartozik valamilyen várható elérési idő a célállapot felé. A várható érték linearitása miatt felírható a követkző “önhivatkozó formula”: $S$ jelöli a lehetséges állapotok halmazát. $p_{s,i}$ jelöli az állapotáteneti mátrix $s$. sorának $i$. oszlopát, vagyis hogy mekkora valószínűséggel lépünk $i$ állapotból $s$ állapotba. \\[\\nu_{j,i} = 1 + \\sum\\limits_{s\\in{}S} \\nu_{j,s}p_{s,i}\\]Itt a Teljes várható érték tételére támaszkodtunk.Ez speciálisan a mi Markov-láncunkra egy nagyon szép dinamikus programozós megoldássá alakul át. Mivel a $0$ állapotot akarjuk elérni, ezért csak az a kérdés melyik állapotból jövünk, jelölje ezt $k$. Jelölje $dp[k]$ azt, hogy mennyi a várható elérési idő a $k$ állapotból a $0$-ba. Tudjuk, hogy $k\\neq{}0$ esetén biztosan kell legalább egyet lépni. Ez a lépés lehet sikertelen ($1-p_k$ valószínűséggel), vagy sikeres ($p_k$ valószínűséggel). A fenti általános képletet felírva erre a feladatra:\\[dp[k] = 1 + (1-p_k) dp[k] + p_k dp[k-1]\\] Végül ezt átrendezve:\\[p_k \\cdot{} dp[k] = 1 + p_k \\cdot{} dp[k-1]\\]\\[dp[k] = \\frac{1}{p_k} + dp[k-1]\\] Továbbá:\\[dp[0] = 0\\]Ebből szépen látszik, hogy\\[dp[k] = \\sum\\limits_{i=1}^{k} \\frac{1}{p_k}\\]Ami pedig pont ugyanaz a képlet, amit a geometriai eloszlásos megoldásból is kihoztunk! :)Megoldás kiírása irreducibilis tört alakbanAz első megoldás esetén a következő összeget kell kiszámoltatni:\\[E = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2} = \\frac{n(n-1)}{2}\\sum\\limits_{i=1}^{k}\\frac{1}{i^2}\\]Hozzuk a szummában szereplő törteket közös nevezőre!Legyen ez a közös nevező $D = \\prod\\limits_{i=1}^{k}i^2$\\[E = \\frac{n(n-1)}{2} \\frac{\\sum\\limits_{i=1}^{k}\\frac{D}{i^2}}{D} = \\frac{P}{Q}\\]Ez azért jó nekünk, mert ennek a törtnek a számlálója és a nevezője is biztosan egész számok, ezért külön ki tudjuk számolni őket:\\[P = n(n-1) \\sum\\limits_{i=1}^{k}\\frac{D}{i^2}\\]\\[Q = 2D\\]Pythonban pedig a pow függvény 3. paraméterébe beírható egy moduló, így moduló lehet vele a $Q$ inverzét meghatározni a $\\frac{P}{Q}$ számolásához.Forráskód:cases = int(input()) for _ in range(cases): n = int(input()) a = list(map(int, input().split())) hatar = 0 # Hol van a határ a végeredmény 0-i és 1-esei között. for i in range(n): if a[i] == 0: hatar += 1 k = 0 # Határ előtti 1-esek száma, ennyit kell elmozgatnunk a határ utánra. for i in range(hatar): if a[i] == 1: k += 1 if k==0: print(0) continue D = 1 for i in range(1, k+1): D *= i*i S = 0 for i in range(1, k+1): S += D / (i * i) P = n*(n-1) * S Q = 2 * D mod = 998244353 QInv = pow(Q, -1, mod) print(int((P * QInv) % mod))És ez jelen pillanatban time limites lesz. :) (TODO)" }, { "title": "Google Code Jam 2021 - Qualification Round", "url": "/posts/2021-04-16-google-code-jam-qualification-round/", "categories": "competitions", "tags": "google, codejam", "date": "2021-04-16 13:00:00 +0200", "snippet": "The 2021 Google Code Jam Qualification Round took place a few weeks ago. The duration of this round is 30 hours, so no matter which timezone you live in around the world, you have more than a whole...", "content": "The 2021 Google Code Jam Qualification Round took place a few weeks ago. The duration of this round is 30 hours, so no matter which timezone you live in around the world, you have more than a whole day to solve the tasks. To advance to the next round, you must have collected at least 30 points, and as usual, it wasn’t necessary to solve all the tasks to do so.The tasks this year were the following: Reversort (7 pont) Moons and Umbrellas (5, 11, 1 pont) Reversort Engineering (7, 11 pont) Median Sort (7, 11, 10 pont) Cheating Detection (11, 20 pont)Let’s look at how we could advance to the next round!1st Task: ReversortDescriptionReversort is an algorithm, that can sort a list of distinct integers in ascending order, using the “Reverse” operation.Each application of this operation reverses the order of some continuous part of the list.The pseudocode of the algorithm is the following:Reversort(L): for i := 1 to length(L) - 1 j := index of the minimum in L[i..] Reverse(L[i..j])The code above iterates over the array and in every step it swaps the number in the current position with the minimum number in the remaining array, such that the numbers between them will be put in reverse order, by reversing that continuous part of the array.We can see, that at the end of the loop, the numbers in the array will be sorted in ascending order.This algorithm is wasteful, the question is by how much. On the input, we receive an array of numbers in random order and we have to print the sum of the length of the subarrays reversed during the algorithm’s run.SolutionThere is only one test set. We can immediately see, that it is very small: $T=100$ cases, at most $N=100$ numbers in each. If we look at the algorithm above, it runs the loop $~N$ times, inside it finds the minimum in $~N$ steps and reverses in $~N$ steps also, which means that it requires around $2\\cdot{}N^2 = 2\\cdot{}10^4$ steps in total. It is important to know, that 1 second is around $10^7$ - $10^8$ instructions (a rough estimate for competitive programming), so we easily fit under 1 second. We have 10 seconds and 1 GB of memory in total for the tests, so we can easily fit into these limits if we just implement the pseudocode as is.It is a good idea to implement this task, because: It gives 7 points, which is a lot, compared to the 30 needed. We only have to translate the given pseudocode to a programming language, which is easy and fast. It has a Visible Verdict, so we can be sure we received those 7 points. The description of the task said, that there will be a similar task later, so we might kill two birds with one stone, if we deal with this task now.I choose Python, because it is compact and has a similar syntax to the pseudocode itself. I usually choose between C++ and Python during competitions, using C++ for more complex tasks, where I want to use the STL library and if the time limits are strict. In this case, Python is the better choice for me.I submitted the following code (without the comments):n = int(input()) # First line of the input: number of testcasesfor n_i in range(n): cost = 0 m = int(input()) # First line of the testcase: length of the array l = list(map(int, input().split(' '))) # Second line of the testcase: the array itself # Implementation of Reversort for i in range(m-1): j = l.index(min(l[i:m])) # Find the minimum element in the remainder of the array. cost += j-i+1 # Add the subarray's length to the total cost. l[i:j+1] = reversed(l[i:j+1]) # Reverse the subarray. print(f\"Case #{n_i+1}: {cost}\") # Print the solution in the correct format.We can see, that we barely had to change anything to implement Reversort in Python and we were done. I had some issues with indexing (lesson learned: all built-in functions in Python assume intervals are closed from the left and open from the right) and I didn’t know about list.index and the reversed functions, I had to look those up.We received 7 points so far, we need 23 more.2nd Task: Moons and UmbrellasDescriptionApart from the story, the task is the following: we receive a string, which contains the characters C, J and ?. We have to switch the ? characters to either C or J, such that in the resulting string, the weighted sum of the number of CJ and JC substrings is as small as possible. The number of CJs is weighted by X and the number of JCs by Y, these parameters are also given on the input.SolutionOf the three test sets, the first (for 5 points) is very small, the string can be of length 10 at most, so here we could try out all possible cases, which amount to at most $2^10$ possibilities. If we were in a situation that we have already solved a few of the other tasks and just these 5 points are missing from the 30, then it would be worth coding just this much and not dealing with the other test sets.The second test set (for 11 points) contains strings of length 1000 at most, which would be $2^1000$ possible solutions for each. Since $2^4 = 16 &gt; 10$, that is greater than $10^250$, which would be too much, even if we could calculate the weight in one step. This test set does not allow for a brute force solution, we have to do some thinking too, however for 11 points, it might be worth dealing with.However, the third test set (for 1 point) is very unsympathetic. It is only worth 1 point, but negative values can also appear among the weights, which must be handled in a completely opposite way (the number of substrings must be maximized instead of minimized), the length of the strings is also $1000$, so we cannot give a brute force algorithm and finally it is a Hidden Verdict, so we won’t even know immediately whether our submission was successful. This is the test case that is not worth dealing with, unless we think of something quick for this while solving the second test set, otherwise we would just be wasting our time.I submitted the following Python code for the first two test sets:n = int(input())for n_i in range(n): x, y, m = input().split() x = int(x) y = int(y) m = m.replace('?', '') xc = m.count('CJ') yc = m.count('JC') print(f\"Case #{n_i+1}: {x*xc + y*yc}\")If we want to just minimize the number of CJs and JCs, without caring about the weights first, then we could simply go through the string from left to right and replace every ? with the character to the left of it (which can no longer be ?, because we must have overwritten it in the previous step), or in the special case the string starts with ?’s, then replace them with the first non-? character, then we get such a minimized solution.We can observe, that no matter what we replace the ?’s with, there is no way to reduce CJ and JC counts, we could only add to it, since for example for every C?…?J, somewhere a CJ substring will occur. So this solution is the best for any non-negative X and Y weights.Finally, it’s much easier to just delete the ?’s, since the method above only “slides” the non-? characters next to each other, so it will not introduce a new alternation, it will only move the existing ones next to each other.For example for this input string:???JC??C??JCJIt will output this one:JJJJCCCCCCJCJWhich has the same number of CJ and JC substrings than the one which results from erasing the ?’s:JCCJCJAnd this can be done in one operation in Python (m.replace('?', '')).Python is a good choice here too, since it is concise and we have 10 seconds per test set, which is more than enough to run the code above.We received 16 more points, we need 7 more.3rd Task: Reversort EngineeringDescriptionThis is the task that starts the same way as Reversort, but now the roles are reversed: now on the input we get the length of the array and the cost and we have to output an array whose sorting will cost this much using Reversort (or write IMPOSSIBLE if this is not possible).SolutionFor the first test set, the length of the array can be at most 7. This is very convenient, because we can try the 7!=5040 possible permutations one by one, run the solution given in the first task on each of them and print a permutation for which the cost is correct. If there is none, then print IMPOSSIBLE. This test set is worth 7 points, which is exactly what we need, so with this solution we are actually done, we could end the competition here.The second test set is more difficult, the length of the array can be at most 100 and the brute force algorithm will run out of time on 100! cases. Since I’ve had a lot of time lest from the competition, I’ve decided to try to solve this test set too.The key to the solution is to think backwards: we start from the final result, the sorted list of length N, we iterate on it backwards and step by step we “reverse” subarrays of the length we choose, until we reach the starting, mixed up list. If we can choose the lengths of the subarrays in such a way that the total sum of their length is the required cost, then the resulting array is the solution. (And here, of course, we have to notice on the task is impossible.)The first observation is that we will use at least 1 cost in each step, since the task says that if the is the smallest element at the current position, we will still “flip” that one-element subarray. Since this will certainly arise as a cost at each position (n-1 times in total), it is worth deducting (accounting for) this at the beginning, so that during further calculations it will not happen that we have used up all the costs but have not yet reached the beginning of the array.The consequence of this is that the cost of reversing an array of length $k$ will be $k-1$ from now on, because $1$ has already been accounted for.And the next observation is that we can choose from the following costs in the given positions from back to front:(Here the array is indexed with 0…n-1, Reversort does not run on the last element of the array, so we start backwards at index $n-2$.) index n-2: 0 if the element on index n-2 is rotated in place, and 1 if indexes n-2 and n-1 are swapped. index n-3: 0,1,2, similarly. index n-4: 0,1,2,3, similarly.… index 0: 0,1,…,n-1.So the task is to assemble the required cost as an amount while we can choose 1 number in each step above. Since we can choose an arbitrarily small number in each step, it is a good strategy to choose the maximum possible in each iteration to reduce the remaining cost as much as possible, unless we exceed it. If the maximum value in the list of possible choices is already more than the remaining cost, then a value equal to the cost is available too and can be selected from the list, then we can choose 0 in the remaining iterations.I implemented this algorithm in Python:# First line of input: number of test cases.z = int(input())for z_i in range(z): # First line of test case: required array length, required cost value. n, c = map(int, input().split(' ')) # First, we quickly rule out impossible cases: # We know that the minimum possible cost is n-1, if the goal is # less than this, then it's impossible. if c &lt; n-1: print(f\"Case #{z_i+1}: IMPOSSIBLE\") continue # To get the maximum possible cost, we choose largest number in each step, # which is the sum of the numbers N,...,2 (there is no 1, because for the # last element Reversort is not run). if n*(n+1)/2-1 &lt; c: print(f\"Case #{z_i+1}: IMPOSSIBLE\") continue # The description of the test sets includes that 2&lt;n, this is unnecessary # here, I just didn't notice. if n == 1: print(f\"Case #{z_i+1}: 1\") continue # At this point a solution exists: # We account for the n-1 cost at the beginning: c -= (n-1) # Here I first calculate the costs in advance (this is not necessary, # it could also be done on the go): # In this array I will store for each starting index the end # of the subarray to be rotated. torev = list(range(n)) # Here I'm going forwards, it is only necessary in the next step to go # backwards. for i in range(n-1): # Here I calculate how much costs I can account for in this iteration # (or the length of the longest possible subarray, or if it is too long, # then I can take the entire remaining cost). j = min(n-1-i, c) # I store where the end of the rotated subarray is. Here I had to # think a bit about the indexes, if there is a +1/-1 somewhere, # but this one is the correct indexing. torev[i] = i + j # I remove from the total cost the value I accounted for in this iteration. c -= j # And here I play the previously stored rotations backwards and # generate the starting array: # We start from the ordered array of length n. l = list(range(1,n+1)) # i=n-2...0 for i in range(n-2,-1,-1): # End of the subarray to be rotated. j = torev[i] # Even more +1/-1 indexing questions. l[i:j+1] = reversed(l[i:j+1]) # Print the solution. st = \" \".join(map(str, l)) print(f\"Case #{z_i+1}: {st}\")There are many ways to calculate the solution here, it is probably not necessary to account for the $n-1$ cost in advance, we could notice on the go if we have run out of the allowed cost. This code could still be simplified by a lot. :)With this solution, we scored 18 more points, which is 41 points in total. Every test set we submitted had a Visible Verdict, so we can be sure that we’ve made it to the next round!" } ]
